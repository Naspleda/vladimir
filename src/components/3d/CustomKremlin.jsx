/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Optimized with: gltf-transform optimize --compress draco
*/

import React, { useEffect, useRef } from 'react'
import { useGraph, useFrame } from '@react-three/fiber'
import { useGLTF } from '@react-three/drei'
import { SkeletonUtils } from 'three-stdlib'
import { useControls } from 'leva'

export function CustomKremlin({ isMobile, ...props }) {
  const { scene } = useGLTF('/assets/CustomKremlin.glb')
  const clone = React.useMemo(() => SkeletonUtils.clone(scene), [scene])
  const { nodes, materials } = useGraph(clone)

  // --- Controles para Material Dorado ---
  const doradoControls = useControls('Material Dorado', {
    color: { value: '#ffcc00', label: 'Color' },
    roughness: { value: 0.24, min: 0, max: 1, step: 0.01, label: 'Roughness' },
    metalness: { value: 1, min: 0, max: 1, step: 0.01, label: 'Metalness' },
    emissive: { value: '#000000', label: 'Emissive' },
    emissiveIntensity: { value: 1, min: 0, max: 10, step: 0.1, label: 'Emissive Intensity' },
  })

  // --- Controles para Material Vidrio ---
  const vidrioControls = useControls('Material Vidrio', {
    color: { value: '#88ccff', label: 'Color' },
    roughness: { value: 0.24, min: 0, max: 1, step: 0.01, label: 'Roughness' },
    metalness: { value: 1, min: 0, max: 1, step: 0.01, label: 'Metalness' },
    opacity: { value: 1, min: 0, max: 1, step: 0.01, label: 'Opacity' },
    transparent: { value: true, label: 'Transparent' },
  })

  // --- Controles para Material Base ---
  const baseControls = useControls('Material Base', {
    color: { value: '#1f429a', label: 'Color' },
    roughness: { value: 0.54, min: 0, max: 1, step: 0.01, label: 'Roughness' },
    metalness: { value: 1, min: 0, max: 1, step: 0.01, label: 'Metalness' },
  })

  useEffect(() => {
    // Actualizar Material Dorado
    if (materials.Dorado) {
      materials.Dorado.color.set(doradoControls.color)
      materials.Dorado.roughness = doradoControls.roughness
      materials.Dorado.metalness = doradoControls.metalness
      materials.Dorado.emissive.set(doradoControls.emissive)
      materials.Dorado.emissiveIntensity = doradoControls.emissiveIntensity
      materials.Dorado.needsUpdate = true
    }

    // Actualizar Material Vidrio (celeste)
    const vidrioMat = materials['Vidrio celeste']
    if (vidrioMat) {
      vidrioMat.color.set(vidrioControls.color)
      vidrioMat.roughness = vidrioControls.roughness
      vidrioMat.metalness = vidrioControls.metalness
      vidrioMat.opacity = vidrioControls.opacity
      vidrioMat.transparent = vidrioControls.transparent
      vidrioMat.needsUpdate = true
    }

    // Actualizar Material Vidrio 2 (celeste.001)
    const vidrioMat2 = materials['Vidrio celeste.001']
    if (vidrioMat2) {
      vidrioMat2.color.set(vidrioControls.color)
      vidrioMat2.roughness = vidrioControls.roughness
      vidrioMat2.metalness = vidrioControls.metalness
      vidrioMat2.opacity = vidrioControls.opacity
      vidrioMat2.transparent = vidrioControls.transparent
      vidrioMat2.needsUpdate = true
    }

    // Actualizar Material Base
    if (materials.Base) {
      materials.Base.color.set(baseControls.color)
      materials.Base.roughness = baseControls.roughness
      materials.Base.metalness = baseControls.metalness
      materials.Base.needsUpdate = true
    }
  }, [materials, doradoControls, vidrioControls, baseControls])

  // --- Controles para Efecto Flotante ---
  const { floating, speed, amplitude, axis } = useControls('Efecto Flotante', {
    floating: { value: true, label: 'Activar' },
    speed: { value: 1, min: 0.1, max: 10, step: 0.1, label: 'Velocidad' },
    amplitude: { value: 1, min: 0.1, max: 10, step: 0.1, label: 'Amplitud' },
    axis: { value: 'y', options: ['x', 'y', 'z'], label: 'Eje' },
  })

  const groupRef = useRef()

  useFrame((state) => {
    if (floating && groupRef.current && !isMobile) {
      const time = state.clock.elapsedTime
      const offset = Math.sin(time * speed) * amplitude

      groupRef.current.position.x = axis === 'x' ? offset : 0
      groupRef.current.position.y = axis === 'y' ? offset : 0
      groupRef.current.position.z = axis === 'z' ? offset : 0
    }
  })

  return (
    <group {...props} dispose={null}>
      <group ref={groupRef}>
        <mesh geometry={nodes.Aro_dorado.geometry} material={materials.Dorado} position={[0, 28.726, -14.042]} scale={[7.101, 0.431, 7.101]} />
        <mesh geometry={nodes.ArosDelanteros.geometry} material={materials['Vidrio celeste']} position={[-13.58, 22.182, -0.6]} scale={[3.055, 0.185, 3.055]} />
        <mesh geometry={nodes.ArosTraseros.geometry} material={materials['Vidrio celeste.001']} position={[-13.58, 22.182, -27.606]} scale={[3.055, 0.185, 3.055]} />
        <mesh geometry={nodes.PuertaArriba.geometry} material={materials.Base} position={[0, 11.054, 45.638]} rotation={[-Math.PI / 2, 0, 0]} scale={[1.032, 1.032, 1.151]} />
        {nodes.Plano012 && (
          <instancedMesh args={[nodes.Plano012.geometry, materials['Vidrio celeste'], 19]} instanceMatrix={nodes.Plano012.instanceMatrix} />
        )}
        {nodes.Plano072 && (
          <instancedMesh args={[nodes.Plano072.geometry, materials['Vidrio celeste'], 12]} instanceMatrix={nodes.Plano072.instanceMatrix} />
        )}
        {nodes.Cylinder && (
          <instancedMesh args={[nodes.Cylinder.geometry, materials.Dorado, 5]} instanceMatrix={nodes.Cylinder.instanceMatrix} />
        )}
      </group>
    </group>
  )
}

useGLTF.preload('/assets/CustomKremlin.glb')
